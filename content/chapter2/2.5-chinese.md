# 2.5 标识线程

线程标识符是`std::thread::id`类型，可以通过两种方式获得。第一种，通过调用`std::thread`对象的成员函数`get_id()`获取。如果`std::thread`对象没有与任何执行线程相关联，`get_id()`将返回一个默认构造的对象，表示“没有对应线程”。第二种，调用定义在`<thread>`头文件中的`std::this_thread::get_id()`函数获得当前线程的标识符。

`std::thread::id`对象可以自由的拷贝和比较，除了作为线程标识外没有其他作用。如果两个`std::thread::id`对象相等，则它们标识同一个线程，或者都表示“没有对应线程”。如果不相等，则表示代表了两个不同的线程，或者一个有对应线程，另一表示“没有对应线程”。

线程库不会限制你去检查线程标识是否一样，`std::thread::id`类型对象提供了完整的比较操作运算符集合，因此定义了不同标识值的全排序（total ordering）。这意味着允许程序员将其当做为关联容器的键值、进行排序，或做其他合适的比较操作。比较操作定义了不同`std::thread::id`值之间的全排序，其行为符合直觉上的预期：如果`a<b`并且`b<c`则`a<c`，等等。标准库也提供了`std::hash<std::thread::id>`，所以`std::thread::id`也可以作为新的无序关联容器的键值。

`std::thread::id`实例常用来检测线程是否需要进行一些特定的操作。例如，如清单2.8中，当用线程来分割一项任务时，主线程可能要做一些与其他线程不同的工作。这种情况下，主线程在启动其他线程前，预先存储`std::this_thread::get_id()`的返回结果，然后在算法的核心部分（通常对所有线程都一样）进行检查，判断其线程标识是否与预先保存的值相同。

```c++
std::thread::id master_thread;
void some_core_part_of_algorithm()
{
  if(std::this_thread::get_id()==master_thread)
  {
    do_master_thread_work();
  }
  do_common_work();
}
```

另外，可以在一个操作中，把当前线程的`std::thread::id`存储到一个数据结构中。在此数据结构的随后的操作中，检查当前线程的ID与存储的线程ID是否匹配，来决定操作是否被允许/需要（permitted/required）。

类似的，作为线程本地存储（thread-local storage）的替代方案，当线程本地存储不适用时，可以将线程ID作为关联数组的键值，将特定数据和线程进行关联。

`std::thread::id`的目的是作为线程的通用标识解决方案，足以满足大多数的应用场景；只有在标识符附带其他语义的情况下（例如作为数组索引的情况）才应该考虑其他替代方案。可以将`std::thread::id`写入输出流，如`std::cout`。

```c++
std::cout<<std::this_thread::get_id();
```

输出结果是严格依赖于具体实现的，C++标准的唯一要求是ID比较结果相等的线程，必须有相同的输出，不相等的有不同的输出。这在调试和日志中会比较有用，但是这些值没有任何语义，所以也就没什么好说的了。

